# -*- coding: utf-8 -*-
# auto-generated by C:\holo_dir\pyholo\c_to_py_tools\helpers.py, None
# auto-generated from C:\holo_release\include\cuda_holo_definitions.h, v1.2-780-g9b58d00
# DO NOT EDIT; WILL BE OVERWRITTEN!


# Do not edit, this file is autogenerated and will be overwritten.
import ctypes
import enum


# Do not edit, this file is autogenerated and will be overwritten.
ctypes_generated_from_vcs_revision = b"v1.2-780-g9b58d00"


# Do not edit, this file is autogenerated and will be overwritten.
# Enums from C:\holo_release\include\cuda_holo_definitions.h


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class RawToPhaseMode(enum.IntEnum):
    UNDEFINED = -1
    CAI_temporal_ps = 0
    FFT_spatial_ps = 1


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class PropagationMethod(enum.IntEnum):
    propagate_fresnel_2_step = 0  # fuer "grosse" Entfernungen
    propagate_convolution = 1  # faltung mit konstanter Pixel-groesse
    propagate_convolution_scaled = 2  # Faltung mit Pixelgroessenanpassung an zu erwartenden Abbildungsmasstab


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class ExtendedDepthMethod(enum.IntEnum):  # spaeter auch shape from focus und andere unrwapping methoden
    unwrap_linewise = 0  # zeilenweises Unwrapping der groessten Synthetischen
    shape_from_focus = 1  # Schaerfekriterium benutzen
    shape_from_large_synth = 2  # multiple propagation planes defined from the largest synthetic wavelength
    global_tilt_estimation = 3  # Schaetzen der Neigung in x und y-Neigung
    cad_matching = 4  # use pre-matched CAD-model for unwrapping


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class PropPlanesSelectionMethod(enum.IntEnum):  # methods to choose proper propagation planes set for extended focus depth
    uniform_distribution = 0  # uniform distribution from min to max
    histogram = 1  # height values with maximum pixels as determined from sorted height histogram


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class TiltCorrectionMethod(enum.IntEnum):  # neu ab 07/2022
    tilt_correction_off = 0
    tilt_correction_on_ring = 1
    tilt_correction_from_gradient = 2
    tilt_correction_from_fft = 3


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class FilterType(enum.IntEnum):
    mean_filter = 0
    gauss_filter = 1
    median_filter = 2


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class ProcessingStep(enum.IntEnum):  # Markante punkte in der Auswertung, zu denen geladen/gespeichert/abgebrochen werden kann - in richtiger Reihenfolge lassen, damit < und > sinnvoll sind.
    STEP_UNDEFINED = 0  # Auch: gar nichts laden, gibt echte Bilder.
    STEP_CAM_IMAGE = 1
    STEP_CAM_CPX = 2  # complexe Daten in der Kameraebene -> fuer Autofocus  // TBe: Unterschied zu "STEP_VIS_PHASES_RAW" ist mir hier beim Lesen nicht klar? MF: Das hier ist vor Propagation: Umbennenen?
    STEP_FFT = 3
    STEP_VIS_PHASES_RAW = 10  # TBe: "Phases" ist hier eigentlich Quatsch: amp/phase wird idR getrennt entschieden.
    STEP_SYN_PHASES_RAW = 20
    STEP_SYN_PHASES_FILTERED = 30
    STEP_APPLIED_FINE_SIGNALS = 35  # Ergebnis nach Zusammensetzen der einzelnen synthetischen L (ab 11/21, MF)
    STEP_SYN_PHASES_COMBINED = 40
    STEP_CONVERTED_TO_HEIGHT = 50


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class VirtualLensMethod(enum.IntEnum):  # wie soll die numerische Linse angewendet werden
    no_virtual_lens = 0
    virtual_lens_before_propagation = 1
    virtual_lens_after_propagation = 2


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class OffsetCompensationMethod(enum.IntEnum):
    NoOffsetCompensation = 0  # Phasenwerte lassen wie sie sind
    OffsetFromRefPoint = 1  # Phasenwerte am Referenzpunk/ROI ausrichten
    OffsetFromGlobalDiff = 2  # Phasenwerte anhand der globalen Differenz ausrichten
    OffsetFromGlobalDiffROIwise = 3  # Phasenwerte innerhalb einzelner ROIs anhand der Differenz ausrichten //TODO: wie funktioniert numerierung?
    OffsetFromHistogram = 4  # Phasenwerte so verschieben, dass der haeufigste Histogrammwert einen Zielwert erreicht
    OffsetFromAutoRefPoint = 5  # Referenzpunkt mit automatischer Suche nach glattem Bereich


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class glass_types(enum.IntEnum):  # aus welchem Gals besteht der Strahlteiler; beachte: wenn hier Aenderung, z.B. Reihenfolge, dann auch in GUI!
    BK7 = 0
    SIO2 = 1
    SF2 = 2
    H_LAK67 = 3


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class NoiseDetectionMethods(enum.IntEnum):
    NoNoiseReduction = 0  # nichts tun
    ReduceAmplitude = 1  # die Amplitude der abweichenden Punkte reduzieren
    WeightedNeigbourhood = 2  # mit Mittelwert der Umgebung (gewichtet) Auffuellen
    ComplexMedianFilter = 3


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class constants(enum.IntEnum):
    mean = 1
    max = 2


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class constants(enum.IntEnum):
    amp_single_laser = 0
    phase_gradient = 1
    amp_diff = 3
    correlation_amp = 4
    correlation_cpx = 5
    std_dev_amp_diff = 6
    normed_std_dev_amps = 7
    gradient_of_amps = 8


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class ConvertToHeightUnits(enum.IntEnum):
    convert_none = 0  # Keep phase values, i.e. no scaling
    convert_to_m = 1  # convert phase data to height values in unit m
    convert_to_mm = 2  # convert phase data to height values in unit mm
    convert_to_micron = 3  # convert phase data to height values in unit micron


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class RotationMethods(enum.IntEnum):
    rotate_0 = 0
    rotate_90 = 1
    rotate_180 = 2
    rotate_270 = 3


# Do not edit, this file is autogenerated and will be overwritten.
@enum.unique
class cv_conversions(enum.IntEnum):
    no_conversion = 0
    toPhase = 1
    toAmp = 2
    toLogAmp = 3  # log-scaled Amp


# Do not edit, this file is autogenerated and will be overwritten.
# Structs from C:\holo_release\include\cuda_holo_definitions.h


# Do not edit, this file is autogenerated and will be overwritten.
class shape_image(ctypes.Structure):
    _fields_ = [
        ("w", ctypes.c_int),
        ("h", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.w = 0
        self.h = 0


# Do not edit, this file is autogenerated and will be overwritten.
class SectionDescription(ctypes.Structure):
    _fields_ = [
        ("x_start", ctypes.c_int),
        ("y_start", ctypes.c_int),
        ("length", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.x_start = 0
        self.y_start = 0
        self.length = 0


# Do not edit, this file is autogenerated and will be overwritten.
class Ring(ctypes.Structure):
    _fields_ = [
        ("center_x", ctypes.c_int),
        ("center_y", ctypes.c_int),
        ("radius", ctypes.c_int),
        ("width", ctypes.c_int),
        ("val_to_multiply", ctypes.c_double),
    ]

    def __init__(self):
        super().__init__()
        self.center_x = 0
        self.center_y = 0
        self.radius = 1
        self.width = 1
        self.val_to_multiply = 1e-6


# Do not edit, this file is autogenerated and will be overwritten.
class Filters(ctypes.Structure):
    _fields_ = [
        ("filterRadius_median", ctypes.c_int),
        ("filterRadius", ctypes.c_int),
        ("filter_scale_rough_signal", ctypes.c_double),
        ("filter_type", ctypes.c_int),
        ("round_average_kernel", ctypes.c_bool),
        ("flag_filter_before_propagate", ctypes.c_bool),
        ("flag_tilt_compensated_filtering", ctypes.c_bool),
        ("flag_apply_led_mask", ctypes.c_bool),
        ("flag_generate_led_mask", ctypes.c_bool),
        ("led_mask_threshold", ctypes.c_int),
        ("led_mask_image_index", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.filterRadius_median = 1
        self.filterRadius = 1
        self.filter_scale_rough_signal = 2.0
        self.filter_type = FilterType.mean_filter
        self.round_average_kernel = False
        self.flag_filter_before_propagate = True
        self.flag_tilt_compensated_filtering = True
        self.flag_apply_led_mask = False
        self.flag_generate_led_mask = False
        self.led_mask_threshold = 0
        self.led_mask_image_index = 0


# Do not edit, this file is autogenerated and will be overwritten.
class Thresholds(ctypes.Structure):
    _fields_ = [
        ("use_threshold", ctypes.c_bool),
        ("threshold_amplitude", ctypes.c_double),
        ("rel_threshold_per_synth", ctypes.c_double),
        ("min_average_camera_modulation_bits", ctypes.c_double),
        ("threshold_combination_error", ctypes.c_double),
        ("flag_mask_overexposed", ctypes.c_bool),
        ("flag_remove_outliers", ctypes.c_bool),
        ("flag_normalize_brightness", ctypes.c_bool),
    ]

    def __init__(self):
        super().__init__()
        self.use_threshold = True
        self.threshold_amplitude = 0
        self.rel_threshold_per_synth = 0.0
        self.min_average_camera_modulation_bits = 3.
        self.threshold_combination_error = 3.1415
        self.flag_mask_overexposed = True
        self.flag_remove_outliers = True
        self.flag_normalize_brightness = True


# Do not edit, this file is autogenerated and will be overwritten.
class NoiseDetectionSettings(ctypes.Structure):
    _fields_ = [
        ("method", ctypes.c_int),
        ("filter_radius_noise_detection", ctypes.c_double),
        ("order", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.method = NoiseDetectionMethods.NoNoiseReduction
        self.filter_radius_noise_detection = 3.0
        self.order = 3


# Do not edit, this file is autogenerated and will be overwritten.
class FlatnessCorrection(ctypes.Structure):
    _fields_ = [
        ("tilt_x", ctypes.c_double),
        ("tilt_y", ctypes.c_double),
        ("second_order_term", ctypes.c_double),
        ("second_order_term_correction_y", ctypes.c_double),
        ("activate_higher_order_polynomial", ctypes.c_bool),
        ("refractive_power_dpt", ctypes.c_double),
        ("virtual_lens_method", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.tilt_x = 0.
        self.tilt_y = 0.
        self.second_order_term = 0.
        self.second_order_term_correction_y = 1.0
        self.activate_higher_order_polynomial = False
        self.refractive_power_dpt = 0.0
        self.virtual_lens_method = VirtualLensMethod.virtual_lens_before_propagation


# Do not edit, this file is autogenerated and will be overwritten.
class GeometricMask(ctypes.Structure):
    _fields_ = [
        ("apply_ring_mask", ctypes.c_bool),
        ("ring_mask", Ring),
    ]

    def __init__(self):
        super().__init__()
        self.apply_ring_mask = False
        self.ring_mask = Ring()


# Do not edit, this file is autogenerated and will be overwritten.
class TiltSettings(ctypes.Structure):
    _fields_ = [
        ("method", ctypes.c_int),
        ("use_mirror_only", ctypes.c_bool),
        ("use_low_pass_filter", ctypes.c_bool),
        ("untilt_each_synth", ctypes.c_bool),
        ("ring_for_roi", Ring),
    ]

    def __init__(self):
        super().__init__()
        self.method = TiltCorrectionMethod.tilt_correction_off
        self.use_mirror_only = False
        self.use_low_pass_filter = False
        self.untilt_each_synth = False
        self.ring_for_roi = Ring()


# Do not edit, this file is autogenerated and will be overwritten.
class CircleTilt(ctypes.Structure):
    _fields_ = [
        ("do_auto_tilt_circle", ctypes.c_bool),
        ("use_mirror_only", ctypes.c_bool),
        ("use_low_pass_filter", ctypes.c_bool),
        ("ring", Ring),
    ]

    def __init__(self):
        super().__init__()
        self.do_auto_tilt_circle = False
        self.use_mirror_only = False
        self.use_low_pass_filter = False
        self.ring = Ring()


# Do not edit, this file is autogenerated and will be overwritten.
class LineTilt(ctypes.Structure):
    _fields_ = [
        ("do_auto_tilt_line", ctypes.c_bool),
        ("section_x", SectionDescription),
        ("section_y", SectionDescription),
    ]

    def __init__(self):
        super().__init__()
        self.do_auto_tilt_line = False
        self.section_x = SectionDescription()
        self.section_y = SectionDescription()


# Do not edit, this file is autogenerated and will be overwritten.
class HoloArea(ctypes.Structure):
    _fields_ = [
        ("x_center", ctypes.c_uint),
        ("y_center", ctypes.c_uint),
        ("width", ctypes.c_uint),
        ("height", ctypes.c_uint),
    ]

    def __init__(self):
        super().__init__()
        self.x_center = 1
        self.y_center = 1
        self.width = 1
        self.height = 1


# Do not edit, this file is autogenerated and will be overwritten.
class OffsetCompensation(HoloArea):
    _fields_ = [
        ("method", ctypes.c_int),
        ("phase_val_target", ctypes.c_double),
        ("phase_offset_roi_combined", ctypes.c_float),
        ("use_mirror_only", ctypes.c_bool),
    ]

    def __init__(self):
        super().__init__()
        self.method = OffsetCompensationMethod.NoOffsetCompensation
        self.phase_val_target = 0.0
        self.phase_offset_roi_combined = 0.0
        self.use_mirror_only = False


# Do not edit, this file is autogenerated and will be overwritten.
class AnchorArea(ctypes.Structure):
    _fields_ = [
        ("area", HoloArea),
        ("apply", ctypes.c_bool),
        ("distance_m", ctypes.c_float),
    ]

    def __init__(self):
        super().__init__()
        self.area = HoloArea()
        self.apply = True
        self.distance_m = 0


# Do not edit, this file is autogenerated and will be overwritten.
class HoloModes(ctypes.Structure):
    _fields_ = [
        ("step_load_as", ctypes.c_int),
        ("step_return_after", ctypes.c_int),
        ("phase_shift_mode", ctypes.c_int),
        ("propagation_method", ctypes.c_int),
        ("phase_shifts_multi_roi", ctypes.c_bool),
        ("auto_downsampling_SPS", ctypes.c_bool),
        ("round_aperture", ctypes.c_bool),
    ]

    def __init__(self):
        super().__init__()
        self.step_load_as = ProcessingStep.STEP_UNDEFINED
        self.step_return_after = ProcessingStep.STEP_SYN_PHASES_COMBINED
        self.phase_shift_mode = RawToPhaseMode.CAI_temporal_ps
        self.propagation_method = PropagationMethod.propagate_convolution
        self.phase_shifts_multi_roi = False
        self.auto_downsampling_SPS = False
        self.round_aperture = False


# Do not edit, this file is autogenerated and will be overwritten.
class HoloDisplaySetting(ctypes.Structure):
    _fields_ = [
        ("max_for_scale", ctypes.c_float),
        ("min_for_scale", ctypes.c_float),
        ("index_of_buffer_to_return", ctypes.c_int),
        ("display_phase", ctypes.c_bool),
    ]

    def __init__(self):
        super().__init__()
        self.max_for_scale = 0.0
        self.min_for_scale = 0.0
        self.index_of_buffer_to_return = 0
        self.display_phase = False


# Do not edit, this file is autogenerated and will be overwritten.
class AutoFocusSetting(ctypes.Structure):
    _fields_ = [
        ("roi", HoloArea),
        ("do_autofocus", ctypes.c_bool),
        ("num_steps", ctypes.c_int),
        ("filter_radius", ctypes.c_int),
        ("dist_estimate_mm", ctypes.c_float),
        ("range_mm", ctypes.c_float),
        ("prop_method", ctypes.c_int),
        ("do_additional_fine_focus", ctypes.c_bool),
        ("is_mirrorlike_surface", ctypes.c_bool),
        ("use_phase_image", ctypes.c_bool),
        ("idx_laser", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.roi = HoloArea()
        self.do_autofocus = False
        self.num_steps = 20
        self.filter_radius = 1
        self.dist_estimate_mm = 0.0
        self.range_mm = 10.0
        self.prop_method = PropagationMethod.propagate_convolution
        self.do_additional_fine_focus = False
        self.is_mirrorlike_surface = True
        self.use_phase_image = False
        self.idx_laser = 0


# Do not edit, this file is autogenerated and will be overwritten.
class ExtendedDepthSetting(ctypes.Structure):
    _fields_ = [
        ("roi", HoloArea),
        ("do_extended_depth", ctypes.c_bool),
        ("do_multi_plane_propagation", ctypes.c_bool),
        ("interpolate_multi_plane", ctypes.c_bool),
        ("searchrange_mm", ctypes.c_float),
        ("num_propagation_distances", ctypes.c_uint),
        ("prop_distance_at_roi_mm", ctypes.c_float),
        ("extended_depth_method", ctypes.c_int),
        ("prop_planes_selection_method", ctypes.c_int),
        ("auto_tilt_estimation", ctypes.c_bool),
        ("tilt_estimation_x_deg", ctypes.c_float),
        ("tilt_estimation_y_deg", ctypes.c_float),
        ("num_planes_sff", ctypes.c_int),
        ("filterradius_median_sff", ctypes.c_int),
        ("use_synth_for_smoothing_sff", ctypes.c_bool),
        ("threshold_sff_quality", ctypes.c_float),
        ("filter_radius_open_sffmask", ctypes.c_int),
        ("filter_radius_close_sffmask", ctypes.c_int),
        ("load_model", ctypes.c_bool),
        ("display_diff_with_cad", ctypes.c_bool),
    ]

    def __init__(self):
        super().__init__()
        self.roi = HoloArea()
        self.do_extended_depth = False
        self.do_multi_plane_propagation = False
        self.interpolate_multi_plane = False
        self.searchrange_mm = 10.0
        self.num_propagation_distances = 8
        self.prop_distance_at_roi_mm = 1.0
        self.extended_depth_method = ExtendedDepthMethod.unwrap_linewise
        self.prop_planes_selection_method = PropPlanesSelectionMethod.uniform_distribution
        self.auto_tilt_estimation = False
        self.tilt_estimation_x_deg = 0.0
        self.tilt_estimation_y_deg = 0.0
        self.num_planes_sff = 20
        self.filterradius_median_sff = 4
        self.use_synth_for_smoothing_sff = False
        self.threshold_sff_quality = 0.85
        self.filter_radius_open_sffmask = 0
        self.filter_radius_close_sffmask = 0
        self.load_model = False
        self.display_diff_with_cad = False


# Do not edit, this file is autogenerated and will be overwritten.
class BackgroundImageSettings(ctypes.Structure):
    _fields_ = [
        ("update_background_image", ctypes.c_bool),
        ("apply_background_image", ctypes.c_bool),
        ("exposure_ms", ctypes.c_double),
        ("is_darkimage", ctypes.c_bool),
        ("low_pass_ratio_for_mirror_x", ctypes.c_double),
        ("low_pass_ratio_for_mirror_y", ctypes.c_double),
    ]

    def __init__(self):
        super().__init__()
        self.update_background_image = False
        self.apply_background_image = False
        self.exposure_ms = 1.0
        self.is_darkimage = False
        self.low_pass_ratio_for_mirror_x = 0.03125
        self.low_pass_ratio_for_mirror_y = 0.03125


# Do not edit, this file is autogenerated and will be overwritten.
class DispersionSettings(ctypes.Structure):
    _fields_ = [
        ("do_dispersion_correction_z", ctypes.c_bool),
        ("do_dispersion_correction_xy", ctypes.c_bool),
        ("thickness_BS_mm", ctypes.c_double),
        ("type_of_glass_BS", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.do_dispersion_correction_z = False
        self.do_dispersion_correction_xy = False
        self.thickness_BS_mm = 0.0
        self.type_of_glass_BS = glass_types.BK7


# Do not edit, this file is autogenerated and will be overwritten.
class GeometricalCorrectionSettings(ctypes.Structure):
    _fields_ = [
        ("apply_aperture_correction", ctypes.c_bool),
        ("apply_sensitivity_vector", ctypes.c_bool),
        ("radius_mirror_detector", ctypes.c_int),
        ("threshold_amplitude_mirrorfilter", ctypes.c_double),
        ("gradual_aperture_correction", ctypes.c_bool),
    ]

    def __init__(self):
        super().__init__()
        self.apply_aperture_correction = False
        self.apply_sensitivity_vector = False
        self.radius_mirror_detector = 1
        self.threshold_amplitude_mirrorfilter = 0.5
        self.gradual_aperture_correction = False


# Do not edit, this file is autogenerated and will be overwritten.
class RawImageQualityThresholds(ctypes.Structure):
    _fields_ = [
        ("max_num_repeats", ctypes.c_int),
        ("current_num_repeats", ctypes.c_int),
        ("flag_stddev_grayvals_as_criterion", ctypes.c_bool),
        ("threshold_stddev_grayvals", ctypes.c_double),
        ("flag_modulation_as_criterion", ctypes.c_bool),
        ("threshold_variation_modulation", ctypes.c_double),
        ("flag_smoothness_as_criterion", ctypes.c_bool),
        ("threshold_variation_smootheness", ctypes.c_double),
        ("flag_phasesteps_as_criterion", ctypes.c_bool),
        ("threshold_variation_phasesteps", ctypes.c_double),
        ("flag_snr_as_criterion", ctypes.c_bool),
        ("threshold_snr", ctypes.c_double),
    ]

    def __init__(self):
        super().__init__()
        self.max_num_repeats = 0
        self.current_num_repeats = 0
        self.flag_stddev_grayvals_as_criterion = False
        self.threshold_stddev_grayvals = 0.5
        self.flag_modulation_as_criterion = False
        self.threshold_variation_modulation = 0.5
        self.flag_smoothness_as_criterion = False
        self.threshold_variation_smootheness = 0.5
        self.flag_phasesteps_as_criterion = False
        self.threshold_variation_phasesteps = 0.5
        self.flag_snr_as_criterion = True
        self.threshold_snr = 1.1


# Do not edit, this file is autogenerated and will be overwritten.
class DetectInFocusSettings(ctypes.Structure):
    _fields_ = [
        ("use_for_global_reference", ctypes.c_bool),
        ("use_for_offset_combination", ctypes.c_bool),
        ("radius_smooth", ctypes.c_double),
        ("binning_factor", ctypes.c_int),
        ("threshold_object_mask", ctypes.c_double),
    ]

    def __init__(self):
        super().__init__()
        self.use_for_global_reference = False
        self.use_for_offset_combination = False
        self.radius_smooth = 2
        self.binning_factor = 64
        self.threshold_object_mask = 0.3


# Do not edit, this file is autogenerated and will be overwritten.
class dim3(ctypes.Structure):
    _fields_ = [
        ("x", ctypes.c_int),
        ("y", ctypes.c_int),
        ("z", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.x = 0
        self.y = 0
        self.z = 0


# Do not edit, this file is autogenerated and will be overwritten.
class HeightValueConversionSettings(ctypes.Structure):
    _fields_ = [
        ("convert_to_height_unit", ctypes.c_int),
        ("revert_untilt", ctypes.c_bool),
        ("transpose_image", ctypes.c_bool),
        ("rotation_type", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.convert_to_height_unit = ConvertToHeightUnits.convert_none
        self.revert_untilt = False
        self.transpose_image = False
        self.rotation_type = RotationMethods.rotate_0


# Do not edit, this file is autogenerated and will be overwritten.
class rect(ctypes.Structure):
    _fields_ = [
        ("x", ctypes.c_int),
        ("y", ctypes.c_int),
        ("w", ctypes.c_int),
        ("h", ctypes.c_int),
    ]

    def __init__(self):
        super().__init__()
        self.x = 0
        self.y = 0
        self.w = 1
        self.h = 1


# Do not edit, this file is autogenerated and will be overwritten.
class names_output_extensions(ctypes.Structure):
    _fields_ = [
    ]

    def __init__(self):
        super().__init__()


# Do not edit, this file is autogenerated and will be overwritten.
class names_output_steps_noextension(ctypes.Structure):
    _fields_ = [
        ("single_lasers_no_ext", ctypes.c_char_p),
        ("fft_no_xt", ctypes.c_char_p),
        ("synth_no_ext", ctypes.c_char_p),
        ("synth_filtered_no_ext", ctypes.c_char_p),
        ("combined_no_ext", ctypes.c_char_p),
        ("converted_to_height", ctypes.c_char_p),
    ]

    def __init__(self):
        super().__init__()
        self.single_lasers_no_ext = b"single laser"
        self.fft_no_xt = b"fft"
        self.synth_no_ext = b"synth. wavelength"
        self.synth_filtered_no_ext = b"synth. wavelength filtered"
        self.combined_no_ext = b"combined"
        self.converted_to_height = b"converted_to_height"


# Do not edit, this file is autogenerated and will be overwritten.
class names_output_images(ctypes.Structure):
    _fields_ = [
        ("converted_to_height_phase", ctypes.c_char_p),
        ("focus_measure", ctypes.c_char_p),
        ("mirror_mask", ctypes.c_char_p),
        ("polygon_mask", ctypes.c_char_p),
        ("mask_for_global_reference", ctypes.c_char_p),
        ("mask_for_offset_compensation", ctypes.c_char_p),
    ]

    def __init__(self):
        super().__init__()
        self.converted_to_height_phase = bnames_output_steps_noextension.converted_to_height
        self.focus_measure = b"focus measure"
        self.mirror_mask = b"mirror mask"
        self.polygon_mask = b"polygon mask"
        self.mask_for_global_reference = b"mask for global reference"
        self.mask_for_offset_compensation = b"offset compensation mask"


# Do not edit, this file is autogenerated and will be overwritten.
class binning_methods(ctypes.Structure):
    _fields_ = [
    ]

    def __init__(self):
        super().__init__()


# Do not edit, this file is autogenerated and will be overwritten.
class focus_criteria(ctypes.Structure):
    _fields_ = [
    ]

    def __init__(self):
        super().__init__()
